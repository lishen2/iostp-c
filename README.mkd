ISO-TP (ISO 15765-2) Support Library in C
================================

**This project is inspired by [openxc isotp-c](https://github.com/openxc/isotp-c), but the code has been completely re-written.**

This is a platform agnostic C library that implements the [ISO 15765-2](https://en.wikipedia.org/wiki/ISO_15765-2) (also known as ISO-TP) protocol, which runs over a CAN bus. Quoting Wikipedia:

>ISO 15765-2, or ISO-TP, is an international standard for sending data packets over a CAN-Bus.
>The protocol allows for the transport of messages that exceed the eight byte maximum payload of CAN frames. 
>ISO-TP segments longer messages into multiple frames, adding metadata that allows the interpretation of individual frames and reassembly 
>into a complete message packet by the recipient. It can carry up to 4095 bytes of payload per message packet.

This library doesn't assume anything about the source of the ISO-TP messages or the underlying interface to CAN. It uses dependency injection to give you complete control.

**The current version supports [ISO-15765-2](https://en.wikipedia.org/wiki/ISO_15765-2) single and multiple frame transmition, and works in Full-duplex mode.**

## Usage

First, create some [shim](https://en.wikipedia.org/wiki/Shim_(computing)) functions to let this library use your lower level system:

```C
    /**
     * @brief  Send CAN message.
     *
     * @param  [in] _id    CAN ID.
     * @param  [in] _buf   Send buffer.
     * @param  [in] _size  Send size.
     * @return Sent size.
     */
    uint8_t  isotp_user_send_can(const uint32_t _id, const uint8_t *const _buf, const uint8_t _size) {
        // ...
    }

    /**
     * @brief  Receive CAN message.
     *
     * @param  [in] _id    CAN ID.
     * @param  [in] _buf   Receive buffer.
     * @param  [in] _size  Receive size.
     * @return Received size.
     */
    uint8_t isotp_user_receive_can(uint32_t *const _id, uint8_t *const _buf, uint8_t _size) {
        // ...
    }

    /**
     * @brief Called when receiving integrity data from network layer.
     *
     * @param [in] _link  ISOTP link.
     * @param [in] _id    Message id.
     * @param [in] _buf   Indication buffer.
     * @param [in] _size  Indication size.
     */
    void indication_to_upperlayer(IsoTpLink *const _link, const uint32_t _id, const uint8_t *const _buf, const uint16_t _size) {
        // ...
    }

    /* required, return system tick, unit is millisecond */
    uint32_t isotp_user_get_ms(void) {
        // ...
    }
    
    /* optional, provide to receive debugging log messages */
    void isotp_user_debug(const char* message, ...) {
        // ...
    }
```

### API

You can use isotp-c in the following way:

```C
    /* Alloc IsoTpLink statically in RAM */
    static IsoTpLink g_link;

	/* Alloc send and receive buffer statically in RAM */
    static uint8_t g_isotpRecvBuf[ISOTP_BUFSIZE];
    static uint8_t g_isotpSendBuf[ISOTP_BUFSIZE];
	
    int main(void) {
        /* Initialize CAN and other peripherals */
        
        /* Initialize link, 0x7TT is the CAN ID you send with and 7RR is the CAN ID you wanted receive */
         isotp_init_link(_link, 0x7TT, 0x7RR, g_isotpSendBuf, sizeof(g_isotpSendBuf), g_isotpRecvBuf, sizeof(g_isotpRecvBuf),
			        isotp_user_send_can, isotp_user_receive_can, indication_to_upperlayer, isotp_user_get_ms, isotp_user_debug);
        
        while(1) {
        
            /* If receive any interested can message, call isotp_indication to handle message */
            ret = can_receive(&id, &data, &len);
            
            /* Indicate ISO-TP  CAN message received */
            if (RET_OK == ret) {
                isotp_indication(&g_link, id, data, len);
            }
            
            /* Poll link to handle multiple frame transmition */
            isotp_poll(&g_link);
            
            /* You can receive message with isotp_receive.
               payload is upper layer message buffer, usually UDS;
               payload_size is payload buffer size;
               out_size is the actuall read size;
               */
            ret = isotp_receive(&g_link, payload, payload_size, &out_size);
            if (ISOTP_RET_OK == ret) {
                /* Handle received message */
            }
            
            /* And send message with isotp_send */
            ret = isotp_send(&g_link, payload, payload_size);
            if (ISOTP_RET_OK == ret) {
                /* Send ok */
            } else {
                /* An error occured */
            }
        }

        return;
    }
```
    
You can call isotp_poll as frequently as you want, as it internally uses isotp_user_get_ms to measure timeout occurences.
If you need handle functional addressing, you must use two separate links, one for each.

```C
    /* Alloc IsoTpLink statically in RAM */
    static IsoTpLink g_phylink;
    static IsoTpLink g_funclink;

	/* Allocate send and receive buffer statically in RAM */
	static uint8_t g_isotpPhyRecvBuf[512];
	static uint8_t g_isotpPhySendBuf[512];
	/* currently functional addressing is not supported with multi-frame messages */
	static uint8_t g_isotpFuncRecvBuf[8];
	static uint8_t g_isotpFuncSendBuf[8];	
	
    int main(void) {
        /* Initialize CAN and other peripherals */
        
        /* Initialize link, 0x7TT is the CAN ID you send with and 7RR is the CAN ID you want receive */
        isotp_init_link(&g_phylink, 0x7TT, 0x7RR,
						g_isotpPhySendBuf, sizeof(g_isotpPhySendBuf), 
						g_isotpPhyRecvBuf, sizeof(g_isotpPhyRecvBuf),
                        isotp_user_send_can, isotp_user_receive_can, indication_to_upperlayer, isotp_user_get_ms, isotp_user_debug);
        isotp_init_link(&g_funclink, 0x7TT, 0x7RR,
						g_isotpFuncSendBuf, sizeof(g_isotpFuncSendBuf), 
						g_isotpFuncRecvBuf, sizeof(g_isotpFuncRecvBuf),
                        isotp_user_send_can, isotp_user_receive_can, indication_to_upperlayer, isotp_user_get_ms, isotp_user_debug);
        
        while(1) {
        
            /* If any CAN messages are received, which are of interest, call isotp_indication to handle the message */
            ret = can_receive(&id, &data, &len);
            
            /* Indicate ISO-TP  CAN message received */
            if (RET_OK == ret) {
                isotp_indication(&g_funclink, id, data, len);
            } 
            
            /* Poll link to handle multiple frame transmition */
            isotp_poll(&g_phylink);
            isotp_poll(&g_funclink);
            
            /* You can receive message with isotp_receive.
               payload is upper layer message buffer, usually UDS;
               payload_size is payload buffer size;
               out_size is the actuall read size;
               */
            ret = isotp_receive(&g_phylink, payload, payload_size, &out_size);
            if (ISOTP_RET_OK == ret) {
                /* Handle physical addressing message */
            }
            
            ret = isotp_receive(&g_funclink, payload, payload_size, &out_size);
            if (ISOTP_RET_OK == ret) {
                /* Handle functional addressing message */
            }            
            
            /* And send message with isotp_send */
            ret = isotp_send(&g_phylink, payload, payload_size);
            if (ISOTP_RET_OK == ret) {
                /* Send ok */
            } else {
                /* An error occured */
            }
        }

        return;
    }
```

## Authors

* **shen.li lishen5@gmail.com** (Original author!)
* **Simon Cahill** **s.cahill@grimme.de** (or **simon@h3lix.de**)

## License

Licensed under the MIT license.
